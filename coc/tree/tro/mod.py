import random
from concurrent.futures import ThreadPoolExecutor, as_completed
from coc.config import MAX_DEPTH, BRANCH_WIDTH
from coc.tree.une import CodeList, TreeNode, root_factory
from coc.tool.task import Task
from typing import Optional
from coc.util.text import extract_code, extract_boxed
from coc.prompts.prompt_troi import prompts_2nd_person
from coc.prompts.prompt_une import build_trunk

def generate_one_child(parent: TreeNode, suggestive_hint: str, llm) -> tuple[TreeNode, Optional[str]]:
    """
    Generate a single child node from a parent using a suggestive prompt.

    Args:
        parent: Parent node to expand from.
        suggestive_hint: Prompt to guide the AI's response.
        llm: Language model function.

    Returns:
        Tuple of (child node, answer if found, else None).
    """
    message = build_trunk(
        task=parent.codelist.env.get_var('task'),
        codes=parent.codelist._,
        suggestive_hint=suggestive_hint,
        variant='force code',
    )
    response = llm(message)
    codes = extract_code(response)
    answer = extract_boxed(response)

    # Create a new child node
    child_codelist = parent.codelist.deepcopy()
    if answer:
        child = TreeNode(
            codelist=child_codelist,
            outputs=parent.outputs + [response],
            parent=parent,
            children=[],
            depth=parent.depth + 1
        )
        return child, answer
    else:
        for code in codes:
            child_codelist.append(code)
        child = TreeNode(
            codelist=child_codelist,
            outputs=parent.outputs + [response],
            parent=parent,
            children=[],
            depth=parent.depth + 1
        )
        return child, None

def generate_children(nodes_with_code: list[TreeNode], num_children: int, llm) -> tuple[list[TreeNode], list[tuple[TreeNode, str]]]:
    """
    Generate multiple child nodes in parallel from the given parent nodes.

    Args:
        nodes_with_code: List of parent nodes that have code (not answers).
        num_children: Number of children to generate (BRANCH_WIDTH).
        llm: Language model function.

    Returns:
        Tuple of (list of child nodes, list of (node, answer) pairs).
    """
    with ThreadPoolExecutor(max_workers=num_children) as executor:
        futures = []
        for _ in range(num_children):
            parent = random.choice(nodes_with_code)
            suggestive_hint = random.choice(prompts_2nd_person)
            futures.append(executor.submit(generate_one_child, parent, suggestive_hint, llm))

        children = []
        answers = []
        for future in as_completed(futures):
            child, answer = future.result()
            children.append(child)
            if answer:
                answers.append((child, answer))
        return children, answers

def evaluate(task: Task, llm) -> list[tuple[TreeNode, str]]:
    """
    Evaluate the task by building a branching tree with suggestive prompts.

    Each depth has BRANCH_WIDTH nodes, generated by randomly selecting parents from the previous depth
    and using random suggestive prompts as AI completion prefixes. Expands up to MAX_DEPTH.

    Args:
        task: The programming task to solve.
        llm: Language model function.

    Returns:
        List of (node, answer) pairs found during tree construction.
    """
    # Initialize the tree with the root node
    root = root_factory(task)
    current_depth_nodes = [root]
    all_answers = []

    # Build the tree depth by depth
    for depth in range(1, MAX_DEPTH + 1):
        # Select nodes that have code (no answer in their last output)
        nodes_with_code = [
            node for node in current_depth_nodes
            if not node.outputs or not extract_boxed(node.outputs[-1])
        ]
        if not nodes_with_code:
            # Stop if no nodes can be expanded further
            break

        # Generate BRANCH_WIDTH children in parallel
        children, answers = generate_children(nodes_with_code, BRANCH_WIDTH, llm)
        all_answers.extend(answers)

        # Update the current depth nodes for the next iteration
        current_depth_nodes = children

    return all_answers

# Example usage (assuming llm is defined elsewhere)
if __name__ == '__main__':
    from coc.tree.llm import llm  # Placeholder for the language model
    sample_task = Task(...)  # Placeholder for a sample task
    answers = evaluate(sample_task, llm)
    for node, answer in answers:
        print(f'Found answer at depth {node.depth}: {answer}')